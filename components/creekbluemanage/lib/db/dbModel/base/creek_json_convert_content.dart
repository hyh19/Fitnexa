import 'package:creek_blue_manage/db/dbModel/creek_hrv_model.dart';import 'package:creek_blue_manage/db/dbModel/creek_sleep_model.dart';import 'package:creek_blue_manage/db/dbModel/creek_spo_model.dart';import 'package:creek_blue_manage/db/dbModel/creek_activity_model.dart';import 'package:creek_blue_manage/db/dbModel/creek_goals_model.dart';import 'package:creek_blue_manage/db/dbModel/creek_heart_rate_model.dart';import 'package:creek_blue_manage/db/dbModel/creek_noise_model.dart';import 'package:creek_blue_manage/db/dbModel/creek_sport_model.dart';import 'package:creek_blue_manage/db/dbModel/creek_stress_model.dart';import '../creek_syncState_model.dart';import '../creek_syncTime_model.dart';JsonConvert jsonConvert = JsonConvert();typedef JsonConvertFunction<T> = T Function(Map<String, dynamic> json);typedef EnumConvertFunction<T> = T Function(String value);class JsonConvert { static final Map<String, JsonConvertFunction> convertFuncMap = {  CreekGoalsModel.toThis(): CreekGoalsModel.fromJson,  CreekHeartRateIntervalModel.toThis(): CreekHeartRateIntervalModel.fromJson,  CreekHeartRateValueModel.toThis(): CreekHeartRateValueModel.fromJson,  CreekStressModel.toThis():CreekStressModel.fromJson,  CreekStressValueModel.toThis():CreekStressValueModel.fromJson,  CreekOxygenModel.toThis():CreekOxygenModel.fromJson,  CreekOxygenValueModel.toThis():CreekOxygenValueModel.fromJson,  CreekNoiseModel.toThis():CreekNoiseModel.fromJson,  CreekNoiseValueModel.toThis():CreekNoiseValueModel.fromJson,  CreekActivityModel.toThis():CreekActivityModel.fromJson,  CreekActivityValueModel.toThis():CreekActivityValueModel.fromJson,  CreekSportModel.toThis():CreekSportModel.fromJson,  CreekSportLocationModel.toThis():CreekSportLocationModel.fromJson,  CreekSleepModel.toThis():CreekSleepModel.fromJson,  CreekSleepValueModel.toThis():CreekSleepValueModel.fromJson,  CreekHrvModel.toThis():CreekHrvModel.fromJson,  CreekHrvValueModel.toThis():CreekHrvValueModel.fromJson,  CreekSyncTimeModel.toThis():CreekSyncTimeModel.fromJson,  CreekSyncStateModel.toThis():CreekSyncStateModel.fromJson,  CreekSpeedPaceItem.toThis():CreekSpeedPaceItem.fromJson, }; T? convert<T>(dynamic value, {EnumConvertFunction? enumConvert}) {  if (value == null) {   return null;  }  if (value is T) {   return value;  }  try {   return _asT<T>(value, enumConvert: enumConvert);  } catch (e, stackTrace) {   return null;  } } List<T?>? convertList<T>(List<dynamic>? value, {EnumConvertFunction? enumConvert}) {  if (value == null) {   return null;  }  try {   return value.map((dynamic e) => _asT<T>(e,enumConvert: enumConvert)).toList();  } catch (e, stackTrace) {   return <T>[];  } } List<T>? convertListNotNull<T>(dynamic value, {EnumConvertFunction? enumConvert}) {  if (value == null) {   return null;  }  try {   return (value as List<dynamic>).map((dynamic e) => _asT<T>(e,enumConvert: enumConvert)!).toList();  } catch (e, stackTrace) {   return <T>[];  } } T? _asT<T extends Object?>(dynamic value,     {EnumConvertFunction? enumConvert}) {  final String type = T.toString();  final String valueS = value.toString();  if (enumConvert != null) {   return enumConvert(valueS) as T;  } else if (type == "String") {   return valueS as T;  } else if (type == "int") {   final int? intValue = int.tryParse(valueS);   if (intValue == null) {    return double.tryParse(valueS)?.toInt() as T?;   } else {    return intValue as T;   }  } else if (type == "double") {   return double.parse(valueS) as T;  } else if (type == "DateTime") {   return DateTime.parse(valueS) as T;  } else if (type == "bool") {   if (valueS == '0' || valueS == '1') {    return (valueS == '1') as T;   }   return (valueS == 'true') as T;  } else if (type == "Map" || type.startsWith("Map<")) {   return value as T;  } else {   if (convertFuncMap.containsKey(type)) {    return convertFuncMap[type]!(Map<String, dynamic>.from(value)) as T;   } else {    throw UnimplementedError('$type unimplemented');   }  } }}